function {@function}) :: boolean:
	return true

options:
	function: foo(

function local() :: number:
	return 1

local function local() :: number:
	return 2

local function bar() :: boolean:
	return true

local function _blob() :: string:
	return "blub"

test "functions":
	assert foo() is true with "function return type failed"
	assert local() is not 1 with "global function parsed before local function"
	assert bar() is true with "local function didn't execute correctly"
	assert _blob() is "blub" with "function that starts with underscore didn't execute correctly"

local function list_argument_single_default(x: texts=("hey")) -> texts:
    return {_x::*}

test "function list argument with a single default value":
	assert list_argument_single_default() = "hey"

local function argument_single_default(x: text="hey") -> text:
    return {_x}

test "function argument with a default value":
	assert argument_single_default() = "hey"

local function literal_test(x: entity type):
	stop

local function literal_test_projectile(x: entity):
	stop

test "literal type parsing":
	parse:
		literal_test(firework)
	assert last parse logs are not set

	spawn an arrow at test-location:
		set {_entity} to entity
		parse:
			literal_test_projectile(projectile)

	assert last parse logs are not set
	clear entity within {_entity}

local function argument_test(x: int, y: int):
	stop

local function argument_test_list(xs: ints):
	stop

test "function structure arguments":
	parse:
		argument_test(1)
	assert last parse logs contain "The function argument_test(integer) does not exist"

	parse:
		argument_test(1, 2)
	assert last parse logs are not set

	parse:
		argument_test(1, 2, 3)
	assert last parse logs contain "The function argument_test(integer, integer, integer) does not exist"

	parse:
		argument_test_list((1, 2, 3))
	assert last parse logs are not set

	parse:
		argument_test_list(1, (2, 3))
	assert last parse logs contain "The function argument_test_list(integer, integers) does not exist"

local function argument_default(x: int, y: int = 2) -> int:
    return {_x} + {_y}

test "function default arguments":
    assert argument_default(2, 3) = 5
    assert argument_default(2) = 4

local function nfa(a: int, b: int, c: int) :: int:
	return {_a} + {_b} - {_c}

local function nfa(a: string, b: string) :: int:
	return 3

test "named function arguments":
	assert nfa(8, 2, 3) = 7

	assert nfa(a: 8, 2, 3) = 7
	assert nfa(a: 8, b: 2, 3) = 7
	assert nfa(a: 8, b: 2, c: 3) = 7

	assert nfa(c: 3, a: 8, b: 2) = 7
	assert nfa(c: 3, b: 2, a: 8) = 7
	assert nfa(a: 8, c: 3, b: 2) = 7

	assert nfa(a: 8, b: 2, 3) = 7
	assert nfa(8, b: 2, c: 3) = 7

	set {_x} to 8
	assert nfa(a: {_x}, b: 2, 3) = 7

	parse:
		assert nfa(a: 8, c: adghadhaherta, b: 2) = 7
	assert first element of last parse logs contains "Can't understand the argument for integer parameter 'c': adghadhaherta"

	parse:
		assert nfa(8, c: 3, b: 2) = 7
	assert last parse logs is not set

	parse:
		assert nfa(c: 3, 2, a: 8) = 7
	assert first element of last parse logs contains "Mixing named and unnamed arguments is not allowed"

	parse:
		assert nfa(c: 3, a: 8, 2) = 7
	assert first element of last parse logs contains "Mixing named and unnamed arguments is not allowed"

	parse:
		assert nfa(b: 2, 3, a: 8) = 7
	assert first element of last parse logs contains "Mixing named and unnamed arguments is not allowed"

	assert nfa("gonna be, gonna be, ""'golden'""", "fire %{_, }%") = 3

	parse:
		nfa(a: 1, b: 2, d: 2)
	assert first element of last parse logs contains "Can't understand the argument for integer parameter 'c': d: 2"

	parse:
		nfa(a: 1, d: 2, b: 2)
	assert first element of last parse logs contains "The argument named 'd' is unexpected"

	parse:
		nfa(a: 1, a: 2, c: 2)
	assert first element of last parse logs contains "A value has already been assigned to parameter 'a'"

	parse:
		set {_loc} to location(x: 1, y: 2, z: 3, yaw: 4, 5)
		assert pitch of {_loc} is 5
	assert last parse logs is not set

	parse:
		location(x: 1, y: 2, z: 3, pitch: 5, yaw: 4)
	assert last parse logs is not set

	parse:
		location(x: 1, y: 2, z: 3, pitch: 4, 5)
	assert first element of last parse logs contains "Mixing named and unnamed arguments is not allowed"

	parse:
		location(x: 1, y: 2, z: 3, 4, world: "world", 5)
	assert first element of last parse logs contains "Mixing named and unnamed arguments is not allowed"

	parse:
		nfa(1 if {_x} is 1, else 2, 3, 4)
	assert last parse logs is "The function nfa(?, ?, integer, integer) does not exist. Did you mean to use the function 'local nfa(a: integer, b: integer, c: integer)'?"

	parse:
		nfa((1 if {_x} is 1, else 2), 3, 4)
	assert last parse logs is not set

local function nfa_incorrect_list(ns: numbers):
	stop

test "named function arguments with single list params":
	parse:
		nfa_incorrect_list(ns: (1, 2, 3))
	assert last parse logs are not set

	parse:
		nfa_incorrect_list(ns: 1, n: 2, 3)
	assert first element of last parse logs contains "The function nfa_incorrect_list(ns: integer, n: integer, integer) does not exist"

	parse:
		nfa_incorrect_list(wrong: (1, 2, 3))
	assert first element of last parse logs contains "The function nfa_incorrect_list(wrong: integers) does not exist"

	parse:
		nfa_incorrect_list(ns: (1, (2, 3)))
	assert first element of last parse logs contains "The function nfa_incorrect_list(ns: integers) does not exist"

	parse:
		nfa_incorrect_list(ns: 1, 2, 3)
	assert first element of last parse logs contains "The function nfa_incorrect_list(ns: integer, integer, integer) does not exist"

	parse:
		nfa_incorrect_list(ns: 1, ns: 2, ns: 3)
	assert first element of last parse logs contains "A value has already been assigned to parameter 'ns'"

local function duplicate_keys_test(x: strings) :: strings:
	return {_x::*}

test "duplicate keys in function arguments":
	set {_a::foo} to "first"
	set {_b::foo} to "second"
	assert duplicate_keys_test(keyed {_a::*}, keyed {_b::*}) is "first"
